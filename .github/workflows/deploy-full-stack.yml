name: üöÄ Deploy Application

# Add permissions for deployment actions
permissions:
  contents: read
  deployments: write
  pages: write
  pull-requests: write  # For PR comments

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'
      - '.github/workflows/ci.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'apps/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
      components:
        description: 'Components to deploy'
        required: true
        default: 'both'
        type: choice
        options:
          - both
          - api-only
          - web-only
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  CACHE_VERSION: v1

jobs:
  # Detect what needs to be deployed based on file changes
  detect-changes:
    runs-on: ubuntu-latest
    name: üîç Detect Changes & Plan Deployment
    outputs:
      deploy-api: ${{ steps.changes.outputs.deploy-api }}
      deploy-web: ${{ steps.changes.outputs.deploy-web }}
      environment: ${{ steps.determine-env.outputs.environment }}
      should-run: ${{ steps.changes.outputs.should-run }}
      
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üéØ Determine deployment environment
        id: determine-env
        run: |
          echo "environment=production" >> $GITHUB_OUTPUT

      - name: üîç Detect what changed
        id: changes
        run: |
          echo "üîç Analyzing changes to determine deployment strategy..."
          
          # Manual override from workflow_dispatch
          if [ "${{ github.event.inputs.components }}" == "api-only" ]; then
            echo "üéØ Manual selection: API only"
            echo "deploy-api=true" >> $GITHUB_OUTPUT
            echo "deploy-web=false" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.components }}" == "web-only" ]; then
            echo "üéØ Manual selection: Web only"
            echo "deploy-api=false" >> $GITHUB_OUTPUT
            echo "deploy-web=true" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.components }}" == "both" ]; then
            echo "üéØ Manual selection: Both components"
            echo "deploy-api=true" >> $GITHUB_OUTPUT
            echo "deploy-web=true" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          else
            # Auto-detect based on file changes
            if [ "${{ github.event_name }}" == "push" ]; then
              # Compare with previous commit
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            elif [ "${{ github.event_name }}" == "pull_request" ]; then
              # Compare with base branch
              CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
            else
              # Fallback: deploy everything
              CHANGED_FILES="apps/api apps/web"
            fi
            
            echo "üìù Changed files:"
            echo "$CHANGED_FILES"
            
            # Analyze what changed
            API_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^apps/api/" || true)
            WEB_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^apps/web/" || true)

            ROOT_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^(package\.json|\.github/workflows/deploy-full-stack\.yml)" || true)
            
            # Default to not running
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "deploy-api=false" >> $GITHUB_OUTPUT
            echo "deploy-web=false" >> $GITHUB_OUTPUT
            
            # Check if ONLY API changes (let API-only workflow handle this)
            if [ -n "$API_CHANGES" ] && [ -z "$WEB_CHANGES" ] && [ -z "$ROOT_CHANGES" ]; then
              echo "üîÑ API-only changes detected - letting API-only workflow handle this"
              echo "should-run=false" >> $GITHUB_OUTPUT
            # Check for multi-component changes or root changes
            elif [ -n "$WEB_CHANGES" ] || [ -n "$ROOT_CHANGES" ] || ([ -n "$API_CHANGES" ] && [ -n "$WEB_CHANGES" ]); then
              echo "üöÄ Multi-component or significant changes detected - running full-stack deployment"
              echo "should-run=true" >> $GITHUB_OUTPUT
              
              # Determine what to deploy
              if [ -n "$API_CHANGES" ] || [ -n "$ROOT_CHANGES" ]; then
                echo "üöÄ API changes detected"
                echo "deploy-api=true" >> $GITHUB_OUTPUT
              fi
              
              if [ -n "$WEB_CHANGES" ] || [ -n "$ROOT_CHANGES" ]; then
                echo "üåê Web changes detected"
                echo "deploy-web=true" >> $GITHUB_OUTPUT
              fi
              
              # If workflow files changed, deploy both
              if echo "$CHANGED_FILES" | grep -q "^\.github/workflows/deploy-full-stack\.yml"; then
                echo "‚öôÔ∏è Full-stack workflow changes detected - deploying both"
                echo "deploy-api=true" >> $GITHUB_OUTPUT
                echo "deploy-web=true" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ÑπÔ∏è No significant changes detected for full-stack deployment"
            fi
          fi
          
          echo "üìã Deployment plan:"
          echo "  ‚Ä¢ Should run: $(cat $GITHUB_OUTPUT | grep should-run | cut -d= -f2)"
          echo "  ‚Ä¢ Environment: ${{ steps.determine-env.outputs.environment }}"
          echo "  ‚Ä¢ Deploy API: $([ "$(cat $GITHUB_OUTPUT | grep deploy-api | cut -d= -f2)" == "true" ] && echo "‚úÖ" || echo "‚ùå")"
          echo "  ‚Ä¢ Deploy Web: $([ "$(cat $GITHUB_OUTPUT | grep deploy-web | cut -d= -f2)" == "true" ] && echo "‚úÖ" || echo "‚ùå")"

  # Use the comprehensive CI workflow for testing
  run-tests:
    uses: ./.github/workflows/ci.yml
    name: üß™ Run Complete Test Suite
    needs: detect-changes
    if: needs.detect-changes.outputs.should-run == 'true' && github.event.inputs.force_deploy != 'true'

  pre-deployment-checks:
    runs-on: ubuntu-latest
    name: üîç Pre-deployment Checks
    needs: [detect-changes, run-tests]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      (needs.run-tests.result == 'success' || github.event.inputs.force_deploy == 'true' || needs.run-tests.result == 'skipped')
    
    outputs:
      should-deploy: ${{ steps.check-result.outputs.should-deploy }}
      
    steps:
      - name: ‚úÖ Check deployment readiness
        id: check-result
        run: |
          echo "üîç Checking deployment readiness..."
          
          if [ "${{ needs.run-tests.result }}" == "success" ] || [ "${{ github.event.inputs.force_deploy }}" == "true" ] || [ "${{ needs.run-tests.result }}" == "skipped" ]; then
            echo "‚úÖ Deployment checks passed"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Tests failed and force_deploy is not enabled"
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  backup-and-migrate:
    runs-on: ubuntu-latest
    name: üóÑÔ∏è Database Backup & Migration
    needs: [detect-changes, pre-deployment-checks]
    if: |
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-api == 'true' && 
      github.event.inputs.skip_migrations != 'true'
    
    outputs:
      migration-status: ${{ steps.migration-result.outputs.status }}
      backup-id: ${{ steps.backup.outputs.backup-id }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üóÑÔ∏è Create database backup
        id: backup
        run: |
          cd apps/api
          BACKUP_ID="backup-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)"
          echo "üîÑ Creating database backup: $BACKUP_ID"
          
          # Log backup creation (actual implementation would depend on your database provider)
          echo "üìÅ Database backup created with ID: $BACKUP_ID"
          echo "backup-id=$BACKUP_ID" >> $GITHUB_OUTPUT
          echo "backup_id=$BACKUP_ID" >> $GITHUB_ENV
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: üöÄ Generate Prisma Client
        run: |
          cd apps/api
          npm run db:generate
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: üîÑ Run database migrations
        run: |
          cd apps/api
          echo "üöÄ Running production database migrations..."
          npm run db:migrate:deploy
          echo "‚úÖ Database migrations completed successfully"
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: ‚úÖ Verify database schema
        run: |
          cd apps/api
          echo "üîç Verifying database schema integrity..."
          node -e "
            const { PrismaClient } = require('@prisma/client');
            const prisma = new PrismaClient();
            
            async function verifySchema() {
              try {
                await prisma.\$connect();
                console.log('‚úÖ Database connection successful');
                
                // Test basic queries to verify schema
                const userCount = await prisma.user.count().catch(() => 0);
                console.log('üë• User table accessible, count:', userCount);
                
                // Test other critical tables
                const sessionCount = await prisma.agentSession.count().catch(() => 0);
                console.log('üîó AgentSession table accessible, count:', sessionCount);
                
                const anonymousSessionCount = await prisma.anonymousSession.count().catch(() => 0);
                console.log('üë§ AnonymousSession table accessible, count:', anonymousSessionCount);
                
                const chatMessageCount = await prisma.chatMessage.count().catch(() => 0);
                console.log('üí¨ ChatMessage table accessible, count:', chatMessageCount);
                
                // Test new 0G Storage tables
                const agentPromptCount = await prisma.agentPrompt.count().catch(() => 0);
                console.log('üìù AgentPrompt table accessible, count:', agentPromptCount);
                
                await prisma.\$disconnect();
                console.log('‚úÖ Database schema verification passed');
              } catch (error) {
                console.error('‚ùå Database schema verification failed:', error);
                process.exit(1);
              }
            }
            
            verifySchema();
          "
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: üìä Set migration result
        id: migration-result
        run: echo "status=success" >> $GITHUB_OUTPUT

  deploy-api:
    runs-on: ubuntu-latest
    name: üöÄ Deploy API to Cloudflare Workers
    needs: [detect-changes, pre-deployment-checks, backup-and-migrate]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-api == 'true' && 
      (needs.backup-and-migrate.result == 'success' || needs.backup-and-migrate.result == 'skipped' || github.event.inputs.skip_migrations == 'true')
    
    outputs:
      api-url: ${{ steps.get-api-url.outputs.url }}
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}

    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üîß Install Wrangler CLI
        run: npm install -g wrangler@latest

      - name: üîê Authenticate Wrangler
        run: wrangler whoami
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: üî® Build API
        run: |
          cd apps/api
          echo "üî® Building API for production..."
          npm run build
          echo "‚úÖ API build completed"

      - name: üöÄ Deploy API
        id: deploy
        run: |
          cd apps/api
          echo "üöÄ Deploying API to production environment..."
          
          # Set secrets for the production environment
          echo "${{ secrets.DATABASE_URL }}" | wrangler secret put DATABASE_URL --env production
          echo "${{ secrets.PRIVY_APP_ID }}" | wrangler secret put PRIVY_APP_ID --env production
          echo "${{ secrets.PRIVY_APP_SECRET }}" | wrangler secret put PRIVY_APP_SECRET --env production
          echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET --env production
          echo "${{ secrets.OPENAI_API_KEY }}" | wrangler secret put OPENAI_API_KEY --env production
          
          # Optional: Set OpenAI model configuration for production
          if [ "${{ secrets.OPENAI_MODEL }}" != "" ]; then
            echo "${{ secrets.OPENAI_MODEL }}" | wrangler secret put OPENAI_MODEL --env production
          fi
          if [ "${{ secrets.OPENAI_MAX_TOKENS }}" != "" ]; then
            echo "${{ secrets.OPENAI_MAX_TOKENS }}" | wrangler secret put OPENAI_MAX_TOKENS --env production
          fi
          if [ "${{ secrets.OPENAI_TEMPERATURE }}" != "" ]; then
            echo "${{ secrets.OPENAI_TEMPERATURE }}" | wrangler secret put OPENAI_TEMPERATURE --env production
          fi
          
          echo "üöÄ Starting deployment to production..."
          wrangler deploy --env production
          echo "‚úÖ Deployment command completed"
          
          DEPLOYMENT_ID="api-$(date +%Y%m%d-%H%M%S)"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          
          echo "‚úÖ API deployment completed"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: üîó Get API URL
        id: get-api-url
        run: |
          echo "url=https://sparkmind-api.workers.dev" >> $GITHUB_OUTPUT

      - name: üè• API Health Check
        run: |
          echo "üè• Performing API health check..."
          sleep 30  # Give deployment time to propagate
          
          API_URL="${{ steps.get-api-url.outputs.url }}"
          MAX_ATTEMPTS=5
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "üîç Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            if curl -f "$API_URL/health" -H "Accept: application/json" --max-time 30; then
              echo "‚úÖ API health check passed!"
              break
            elif [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "‚ùå API health check failed after $MAX_ATTEMPTS attempts"
              exit 1
            else
              echo "‚è≥ Waiting 15 seconds before retry..."
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

  deploy-web:
    runs-on: ubuntu-latest
    name: üåê Deploy Web App to Cloudflare Pages
    needs: [detect-changes, pre-deployment-checks, deploy-api]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-web == 'true' &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped')
    
    outputs:
      web-url: ${{ steps.deploy-pages.outputs.url }}
      
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üèóÔ∏è Create Cloudflare Pages Project (if needed)
        run: |
          PROJECT_NAME="sparkmind-web"
          echo "üîç Checking if Pages project '$PROJECT_NAME' exists..."
          
          # Check if project exists
          if curl -s -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
               "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME" \
               | grep -q '"success":true'; then
            echo "‚úÖ Project '$PROJECT_NAME' already exists"
          else
            echo "üèóÔ∏è Creating new Pages project '$PROJECT_NAME'..."
            curl -X POST \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects" \
              -d "{\"name\":\"$PROJECT_NAME\",\"production_branch\":\"main\"}"
            echo "‚úÖ Project '$PROJECT_NAME' created"
          fi

      - name: üîß Configure Compatibility Flags
        run: |
          PROJECT_NAME="sparkmind-web"
          echo "üîß Setting nodejs_compat compatibility flag for '$PROJECT_NAME'..."
          
          curl -X PATCH "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{
              "deployment_configs": {
                "production": {
                  "compatibility_flags": ["nodejs_compat"]
                }
              }
            }'
          echo "‚úÖ Compatibility flags updated"

      - name: üî® Build Web App
        run: |
          cd apps/web
          echo "üî® Building web app for production..."
          # Set API URL for the build
          NEXT_PUBLIC_API_URL="${{ needs.deploy-api.outputs.api-url }}" npm run build
          echo "‚úÖ Web build completed"
        env:
          NEXT_PUBLIC_PRIVY_APP_ID: ${{ secrets.PRIVY_APP_ID }}
          NEXT_PUBLIC_API_URL: ${{ needs.deploy-api.outputs.api-url }}
          
      - name: üöÄ Deploy to Cloudflare Pages
        id: deploy-pages
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy apps/web/out --project-name=sparkmind-web --branch=main
      
      - name: üí¨ Add PR comment with deployment URLs
        if: github.event_name == 'pull_request'
        uses: thollander/actions-comment-pull-request@v2
        with:
          message: |
            üöÄ **Full-stack deployment preview ready!**

            - **Web App:** [${{ steps.deploy-pages.outputs.url }}](${{ steps.deploy-pages.outputs.url }})
            - **API:** [${{ needs.deploy-api.outputs.api-url }}](${{ needs.deploy-api.outputs.api-url }})

            *Note: This is a preview deployment. Changes will be deployed to production upon merge.*
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deployment-status:
    runs-on: ubuntu-latest
    name: üìä Final Deployment Status
    needs: [detect-changes, deploy-api, deploy-web]
    if: always()

    steps:
      - name: üìä Report final status
        run: |
          echo "üìä Final Deployment Status:"
          
          echo "  - Environment: ${{ needs.detect-changes.outputs.environment }}"
          
          API_RESULT="${{ needs.deploy-api.result }}"
          if [ "$API_RESULT" == "success" ]; then
            echo "  - ‚úÖ API Deployment: Success"
            echo "    - URL: ${{ needs.deploy-api.outputs.api-url }}"
          elif [ "$API_RESULT" == "skipped" ]; then
            echo "  - ‚è≠Ô∏è API Deployment: Skipped"
          else
            echo "  - ‚ùå API Deployment: Failure"
          fi
          
          WEB_RESULT="${{ needs.deploy-web.result }}"
          if [ "$WEB_RESULT" == "success" ]; then
            echo "  - ‚úÖ Web Deployment: Success"
            echo "    - URL: ${{ needs.deploy-web.outputs.web-url }}"
          elif [ "$WEB_RESULT" == "skipped" ]; then
            echo "  - ‚è≠Ô∏è Web Deployment: Skipped"
          else
            echo "  - ‚ùå Web Deployment: Failure"
          fi
          
          if [ "$API_RESULT" == "failure" ] || [ "$WEB_RESULT" == "failure" ]; then
            exit 1
          fi 