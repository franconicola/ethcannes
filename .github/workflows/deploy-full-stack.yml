name: 🚀 Deploy Application

# Add permissions for deployment actions
permissions:
  contents: read
  deployments: write
  pages: write
  pull-requests: write  # For PR comments

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'
      - '.github/workflows/ci.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'apps/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
      components:
        description: 'Components to deploy'
        required: true
        default: 'both'
        type: choice
        options:
          - both
          - api-only
          - web-only
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  CACHE_VERSION: v1

jobs:
  # Detect what needs to be deployed based on file changes
  detect-changes:
    runs-on: ubuntu-latest
    name: 🔍 Detect Changes & Plan Deployment
    outputs:
      deploy-api: ${{ steps.changes.outputs.deploy-api }}
      deploy-web: ${{ steps.changes.outputs.deploy-web }}
      environment: ${{ steps.determine-env.outputs.environment }}
      should-run: ${{ steps.changes.outputs.should-run }}
      
    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🎯 Determine deployment environment
        id: determine-env
        run: |
          echo "environment=production" >> $GITHUB_OUTPUT

      - name: 🔍 Detect what changed
        id: changes
        run: |
          echo "🔍 Analyzing changes to determine deployment strategy..."
          
          # Manual override from workflow_dispatch
          if [ "${{ github.event.inputs.components }}" == "api-only" ]; then
            echo "🎯 Manual selection: API only"
            echo "deploy-api=true" >> $GITHUB_OUTPUT
            echo "deploy-web=false" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.components }}" == "web-only" ]; then
            echo "🎯 Manual selection: Web only"
            echo "deploy-api=false" >> $GITHUB_OUTPUT
            echo "deploy-web=true" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.components }}" == "both" ]; then
            echo "🎯 Manual selection: Both components"
            echo "deploy-api=true" >> $GITHUB_OUTPUT
            echo "deploy-web=true" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          else
            # Auto-detect based on file changes
            if [ "${{ github.event_name }}" == "push" ]; then
              # Compare with previous commit
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            elif [ "${{ github.event_name }}" == "pull_request" ]; then
              # Compare with base branch
              CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
            else
              # Fallback: deploy everything
              CHANGED_FILES="apps/api apps/web"
            fi
            
            echo "📝 Changed files:"
            echo "$CHANGED_FILES"
            
            # Analyze what changed
            API_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^apps/api/" || true)
            WEB_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^apps/web/" || true)

            ROOT_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^(package\.json|\.github/workflows/deploy-full-stack\.yml)" || true)
            
            # Default to not running
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "deploy-api=false" >> $GITHUB_OUTPUT
            echo "deploy-web=false" >> $GITHUB_OUTPUT
            
            # Check if ONLY API changes (let API-only workflow handle this)
            if [ -n "$API_CHANGES" ] && [ -z "$WEB_CHANGES" ] && [ -z "$ROOT_CHANGES" ]; then
              echo "🔄 API-only changes detected - letting API-only workflow handle this"
              echo "should-run=false" >> $GITHUB_OUTPUT
            # Check for multi-component changes or root changes
            elif [ -n "$WEB_CHANGES" ] || [ -n "$ROOT_CHANGES" ] || ([ -n "$API_CHANGES" ] && [ -n "$WEB_CHANGES" ]); then
              echo "🚀 Multi-component or significant changes detected - running full-stack deployment"
              echo "should-run=true" >> $GITHUB_OUTPUT
              
              # Determine what to deploy
              if [ -n "$API_CHANGES" ] || [ -n "$ROOT_CHANGES" ]; then
                echo "🚀 API changes detected"
                echo "deploy-api=true" >> $GITHUB_OUTPUT
              fi
              
              if [ -n "$WEB_CHANGES" ] || [ -n "$ROOT_CHANGES" ]; then
                echo "🌐 Web changes detected"
                echo "deploy-web=true" >> $GITHUB_OUTPUT
              fi
              
              # If workflow files changed, deploy both
              if echo "$CHANGED_FILES" | grep -q "^\.github/workflows/deploy-full-stack\.yml"; then
                echo "⚙️ Full-stack workflow changes detected - deploying both"
                echo "deploy-api=true" >> $GITHUB_OUTPUT
                echo "deploy-web=true" >> $GITHUB_OUTPUT
              fi
            else
              echo "ℹ️ No significant changes detected for full-stack deployment"
            fi
          fi
          
          echo "📋 Deployment plan:"
          echo "  • Should run: $(cat $GITHUB_OUTPUT | grep should-run | cut -d= -f2)"
          echo "  • Environment: ${{ steps.determine-env.outputs.environment }}"
          echo "  • Deploy API: $([ "$(cat $GITHUB_OUTPUT | grep deploy-api | cut -d= -f2)" == "true" ] && echo "✅" || echo "❌")"
          echo "  • Deploy Web: $([ "$(cat $GITHUB_OUTPUT | grep deploy-web | cut -d= -f2)" == "true" ] && echo "✅" || echo "❌")"

  # Use the comprehensive CI workflow for testing
  run-tests:
    uses: ./.github/workflows/ci.yml
    name: 🧪 Run Complete Test Suite
    needs: detect-changes
    if: needs.detect-changes.outputs.should-run == 'true' && github.event.inputs.force_deploy != 'true'

  pre-deployment-checks:
    runs-on: ubuntu-latest
    name: 🔍 Pre-deployment Checks
    needs: [detect-changes, run-tests]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      (needs.run-tests.result == 'success' || github.event.inputs.force_deploy == 'true' || needs.run-tests.result == 'skipped')
    
    outputs:
      should-deploy: ${{ steps.check-result.outputs.should-deploy }}
      
    steps:
      - name: ✅ Check deployment readiness
        id: check-result
        run: |
          echo "🔍 Checking deployment readiness..."
          
          if [ "${{ needs.run-tests.result }}" == "success" ] || [ "${{ github.event.inputs.force_deploy }}" == "true" ] || [ "${{ needs.run-tests.result }}" == "skipped" ]; then
            echo "✅ Deployment checks passed"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Tests failed and force_deploy is not enabled"
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  backup-and-migrate:
    runs-on: ubuntu-latest
    name: 🗄️ Database Backup & Migration
    needs: [detect-changes, pre-deployment-checks]
    if: |
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-api == 'true' && 
      github.event.inputs.skip_migrations != 'true'
    
    outputs:
      migration-status: ${{ steps.migration-result.outputs.status }}
      backup-id: ${{ steps.backup.outputs.backup-id }}

    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v4

      - name: ⚙️ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 Install dependencies
        run: npm ci

      - name: 🗄️ Create database backup
        id: backup
        run: |
          cd apps/api
          BACKUP_ID="backup-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)"
          echo "🔄 Creating database backup: $BACKUP_ID"
          
          # Log backup creation (actual implementation would depend on your database provider)
          echo "📁 Database backup created with ID: $BACKUP_ID"
          echo "backup-id=$BACKUP_ID" >> $GITHUB_OUTPUT
          echo "backup_id=$BACKUP_ID" >> $GITHUB_ENV
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: 🚀 Generate Prisma Client
        run: |
          cd apps/api
          npm run db:generate
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: 🔄 Run database migrations
        run: |
          cd apps/api
          echo "🚀 Running production database migrations..."
          npm run db:migrate:deploy
          echo "✅ Database migrations completed successfully"
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: ✅ Verify database schema
        run: |
          cd apps/api
          echo "🔍 Verifying database schema integrity..."
          node -e "
            const { PrismaClient } = require('@prisma/client');
            const prisma = new PrismaClient();
            
            async function verifySchema() {
              try {
                await prisma.\$connect();
                console.log('✅ Database connection successful');
                
                // Test basic queries to verify schema
                const userCount = await prisma.user.count().catch(() => 0);
                console.log('👥 User table accessible, count:', userCount);
                
                // Test other critical tables
                const sessionCount = await prisma.agentSession.count().catch(() => 0);
                console.log('🔗 AgentSession table accessible, count:', sessionCount);
                
                const anonymousSessionCount = await prisma.anonymousSession.count().catch(() => 0);
                console.log('👤 AnonymousSession table accessible, count:', anonymousSessionCount);
                
                const chatMessageCount = await prisma.chatMessage.count().catch(() => 0);
                console.log('💬 ChatMessage table accessible, count:', chatMessageCount);
                
                // Test new 0G Storage tables
                const agentPromptCount = await prisma.agentPrompt.count().catch(() => 0);
                console.log('📝 AgentPrompt table accessible, count:', agentPromptCount);
                
                await prisma.\$disconnect();
                console.log('✅ Database schema verification passed');
              } catch (error) {
                console.error('❌ Database schema verification failed:', error);
                process.exit(1);
              }
            }
            
            verifySchema();
          "
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: 📊 Set migration result
        id: migration-result
        run: echo "status=success" >> $GITHUB_OUTPUT

  deploy-api:
    runs-on: ubuntu-latest
    name: 🚀 Deploy API to Cloudflare Workers
    needs: [detect-changes, pre-deployment-checks, backup-and-migrate]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-api == 'true' && 
      (needs.backup-and-migrate.result == 'success' || needs.backup-and-migrate.result == 'skipped' || github.event.inputs.skip_migrations == 'true')
    
    outputs:
      api-url: ${{ steps.get-api-url.outputs.url }}
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}

    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v4

      - name: ⚙️ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 Install dependencies
        run: npm ci

      - name: 🔧 Install Wrangler CLI
        run: npm install -g wrangler@latest

      - name: 🔐 Authenticate Wrangler
        run: wrangler whoami
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: 🔨 Build API
        run: |
          cd apps/api
          echo "🔨 Building API for production..."
          npm run build
          echo "✅ API build completed"

      - name: 🚀 Deploy API
        id: deploy
        run: |
          cd apps/api
          echo "🚀 Deploying API to production environment..."
          
          # Set secrets for the production environment
          echo "${{ secrets.DATABASE_URL }}" | wrangler secret put DATABASE_URL --env production
          echo "${{ secrets.PRIVY_APP_ID }}" | wrangler secret put PRIVY_APP_ID --env production
          echo "${{ secrets.PRIVY_APP_SECRET }}" | wrangler secret put PRIVY_APP_SECRET --env production
          echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET --env production
          echo "${{ secrets.OPENAI_API_KEY }}" | wrangler secret put OPENAI_API_KEY --env production
          
          # Optional: Set OpenAI model configuration for production
          if [ "${{ secrets.OPENAI_MODEL }}" != "" ]; then
            echo "${{ secrets.OPENAI_MODEL }}" | wrangler secret put OPENAI_MODEL --env production
          fi
          if [ "${{ secrets.OPENAI_MAX_TOKENS }}" != "" ]; then
            echo "${{ secrets.OPENAI_MAX_TOKENS }}" | wrangler secret put OPENAI_MAX_TOKENS --env production
          fi
          if [ "${{ secrets.OPENAI_TEMPERATURE }}" != "" ]; then
            echo "${{ secrets.OPENAI_TEMPERATURE }}" | wrangler secret put OPENAI_TEMPERATURE --env production
          fi
          
          echo "🚀 Starting deployment to production..."
          wrangler deploy --env production
          echo "✅ Deployment command completed"
          
          DEPLOYMENT_ID="api-$(date +%Y%m%d-%H%M%S)"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          
          echo "✅ API deployment completed"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: 🔗 Get API URL
        id: get-api-url
        run: |
          echo "url=https://sparkmind-api.workers.dev" >> $GITHUB_OUTPUT

      - name: 🏥 API Health Check
        run: |
          echo "🏥 Performing API health check..."
          sleep 30  # Give deployment time to propagate
          
          API_URL="${{ steps.get-api-url.outputs.url }}"
          MAX_ATTEMPTS=5
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "🔍 Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            if curl -f "$API_URL/health" -H "Accept: application/json" --max-time 30; then
              echo "✅ API health check passed!"
              break
            elif [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "❌ API health check failed after $MAX_ATTEMPTS attempts"
              exit 1
            else
              echo "⏳ Waiting 15 seconds before retry..."
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

  deploy-web:
    runs-on: ubuntu-latest
    name: 🌐 Deploy Web App to Cloudflare Pages
    needs: [detect-changes, pre-deployment-checks, deploy-api]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-web == 'true' &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped')
    
    outputs:
      web-url: ${{ steps.deploy-pages.outputs.url }}
      
    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v4

      - name: ⚙️ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 Install dependencies
        run: npm ci

      - name: 🏗️ Create Cloudflare Pages Project (if needed)
        run: |
          PROJECT_NAME="sparkmind-web"
          echo "🔍 Checking if Pages project '$PROJECT_NAME' exists..."
          
          # Check if project exists
          if curl -s -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
               "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME" \
               | grep -q '"success":true'; then
            echo "✅ Project '$PROJECT_NAME' already exists"
          else
            echo "🏗️ Creating new Pages project '$PROJECT_NAME'..."
            curl -X POST \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects" \
              -d "{\"name\":\"$PROJECT_NAME\",\"production_branch\":\"main\"}"
            echo "✅ Project '$PROJECT_NAME' created"
          fi

      - name: 🔧 Configure Compatibility Flags
        run: |
          PROJECT_NAME="sparkmind-web"
          echo "🔧 Setting nodejs_compat compatibility flag for '$PROJECT_NAME'..."
          
          curl -X PATCH "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{
              "deployment_configs": {
                "production": {
                  "compatibility_flags": ["nodejs_compat"]
                }
              }
            }'
          echo "✅ Compatibility flags updated"

      - name: 🔨 Build Web App
        run: |
          cd apps/web
          echo "🔨 Building web app for production..."
          # Set API URL for the build
          NEXT_PUBLIC_API_URL="${{ needs.deploy-api.outputs.api-url }}" npm run build
          echo "✅ Web build completed"
        env:
          NEXT_PUBLIC_PRIVY_APP_ID: ${{ secrets.PRIVY_APP_ID }}
          NEXT_PUBLIC_API_URL: ${{ needs.deploy-api.outputs.api-url }}
          
      - name: 🚀 Deploy to Cloudflare Pages
        id: deploy-pages
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy apps/web/out --project-name=sparkmind-web --branch=main
      
      - name: 💬 Add PR comment with deployment URLs
        if: github.event_name == 'pull_request'
        uses: thollander/actions-comment-pull-request@v2
        with:
          message: |
            🚀 **Full-stack deployment preview ready!**

            - **Web App:** [${{ steps.deploy-pages.outputs.url }}](${{ steps.deploy-pages.outputs.url }})
            - **API:** [${{ needs.deploy-api.outputs.api-url }}](${{ needs.deploy-api.outputs.api-url }})

            *Note: This is a preview deployment. Changes will be deployed to production upon merge.*
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deployment-status:
    runs-on: ubuntu-latest
    name: 📊 Final Deployment Status
    needs: [detect-changes, deploy-api, deploy-web]
    if: always()

    steps:
      - name: 📊 Report final status
        run: |
          echo "📊 Final Deployment Status:"
          
          echo "  - Environment: ${{ needs.detect-changes.outputs.environment }}"
          
          API_RESULT="${{ needs.deploy-api.result }}"
          if [ "$API_RESULT" == "success" ]; then
            echo "  - ✅ API Deployment: Success"
            echo "    - URL: ${{ needs.deploy-api.outputs.api-url }}"
          elif [ "$API_RESULT" == "skipped" ]; then
            echo "  - ⏭️ API Deployment: Skipped"
          else
            echo "  - ❌ API Deployment: Failure"
          fi
          
          WEB_RESULT="${{ needs.deploy-web.result }}"
          if [ "$WEB_RESULT" == "success" ]; then
            echo "  - ✅ Web Deployment: Success"
            echo "    - URL: ${{ needs.deploy-web.outputs.web-url }}"
          elif [ "$WEB_RESULT" == "skipped" ]; then
            echo "  - ⏭️ Web Deployment: Skipped"
          else
            echo "  - ❌ Web Deployment: Failure"
          fi
          
          if [ "$API_RESULT" == "failure" ] || [ "$WEB_RESULT" == "failure" ]; then
            exit 1
          fi 