name: ðŸš€ Deploy Application

# Add permissions for deployment actions
permissions:
  contents: read
  deployments: write
  pages: write
  pull-requests: write  # For PR comments

on:
  push:
    branches:
      - main
      - develop
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'
      - '.github/workflows/ci.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'apps/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - development
      components:
        description: 'Components to deploy'
        required: true
        default: 'both'
        type: choice
        options:
          - both
          - api-only
          - web-only
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  CACHE_VERSION: v1

jobs:
  # Detect what needs to be deployed based on file changes
  detect-changes:
    runs-on: ubuntu-latest
    name: ðŸ” Detect Changes & Plan Deployment
    outputs:
      deploy-api: ${{ steps.changes.outputs.deploy-api }}
      deploy-web: ${{ steps.changes.outputs.deploy-web }}
      environment: ${{ steps.determine-env.outputs.environment }}
      should-run: ${{ steps.changes.outputs.should-run }}
      
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸŽ¯ Determine deployment environment
        id: determine-env
        run: |
          if [ "${{ github.event.inputs.environment }}" != "" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ” Detect what changed
        id: changes
        run: |
          echo "ðŸ” Analyzing changes to determine deployment strategy..."
          
          # Manual override from workflow_dispatch
          if [ "${{ github.event.inputs.components }}" == "api-only" ]; then
            echo "ðŸŽ¯ Manual selection: API only"
            echo "deploy-api=true" >> $GITHUB_OUTPUT
            echo "deploy-web=false" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.components }}" == "web-only" ]; then
            echo "ðŸŽ¯ Manual selection: Web only"
            echo "deploy-api=false" >> $GITHUB_OUTPUT
            echo "deploy-web=true" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.components }}" == "both" ]; then
            echo "ðŸŽ¯ Manual selection: Both components"
            echo "deploy-api=true" >> $GITHUB_OUTPUT
            echo "deploy-web=true" >> $GITHUB_OUTPUT
            echo "should-run=true" >> $GITHUB_OUTPUT
          else
            # Auto-detect based on file changes
            if [ "${{ github.event_name }}" == "push" ]; then
              # Compare with previous commit
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            elif [ "${{ github.event_name }}" == "pull_request" ]; then
              # Compare with base branch
              CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
            else
              # Fallback: deploy everything
              CHANGED_FILES="apps/api apps/web"
            fi
            
            echo "ðŸ“ Changed files:"
            echo "$CHANGED_FILES"
            
            # Analyze what changed
            API_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^apps/api/" || true)
            WEB_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^apps/web/" || true)

            ROOT_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^(package\.json|\.github/workflows/deploy-full-stack\.yml)" || true)
            
            # Default to not running
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "deploy-api=false" >> $GITHUB_OUTPUT
            echo "deploy-web=false" >> $GITHUB_OUTPUT
            
            # Check if ONLY API changes (let API-only workflow handle this)
            if [ -n "$API_CHANGES" ] && [ -z "$WEB_CHANGES" ] && [ -z "$ROOT_CHANGES" ]; then
              echo "ðŸ”„ API-only changes detected - letting API-only workflow handle this"
              echo "should-run=false" >> $GITHUB_OUTPUT
            # Check for multi-component changes or root changes
            elif [ -n "$WEB_CHANGES" ] || [ -n "$ROOT_CHANGES" ] || ([ -n "$API_CHANGES" ] && [ -n "$WEB_CHANGES" ]); then
              echo "ðŸš€ Multi-component or significant changes detected - running full-stack deployment"
              echo "should-run=true" >> $GITHUB_OUTPUT
              
              # Determine what to deploy
              if [ -n "$API_CHANGES" ] || [ -n "$ROOT_CHANGES" ]; then
                echo "ðŸš€ API changes detected"
                echo "deploy-api=true" >> $GITHUB_OUTPUT
              fi
              
              if [ -n "$WEB_CHANGES" ] || [ -n "$ROOT_CHANGES" ]; then
                echo "ðŸŒ Web changes detected"
                echo "deploy-web=true" >> $GITHUB_OUTPUT
              fi
              
              # If workflow files changed, deploy both
              if echo "$CHANGED_FILES" | grep -q "^\.github/workflows/deploy-full-stack\.yml"; then
                echo "âš™ï¸ Full-stack workflow changes detected - deploying both"
                echo "deploy-api=true" >> $GITHUB_OUTPUT
                echo "deploy-web=true" >> $GITHUB_OUTPUT
              fi
            else
              echo "â„¹ï¸ No significant changes detected for full-stack deployment"
            fi
          fi
          
          echo "ðŸ“‹ Deployment plan:"
          echo "  â€¢ Should run: $(cat $GITHUB_OUTPUT | grep should-run | cut -d= -f2)"
          echo "  â€¢ Environment: ${{ steps.determine-env.outputs.environment }}"
          echo "  â€¢ Deploy API: $([ "$(cat $GITHUB_OUTPUT | grep deploy-api | cut -d= -f2)" == "true" ] && echo "âœ…" || echo "âŒ")"
          echo "  â€¢ Deploy Web: $([ "$(cat $GITHUB_OUTPUT | grep deploy-web | cut -d= -f2)" == "true" ] && echo "âœ…" || echo "âŒ")"

  # Use the comprehensive CI workflow for testing
  run-tests:
    uses: ./.github/workflows/ci.yml
    name: ðŸ§ª Run Complete Test Suite
    needs: detect-changes
    if: needs.detect-changes.outputs.should-run == 'true' && github.event.inputs.force_deploy != 'true'

  pre-deployment-checks:
    runs-on: ubuntu-latest
    name: ðŸ” Pre-deployment Checks
    needs: [detect-changes, run-tests]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      (needs.run-tests.result == 'success' || github.event.inputs.force_deploy == 'true' || needs.run-tests.result == 'skipped')
    
    outputs:
      should-deploy: ${{ steps.check-result.outputs.should-deploy }}
      
    steps:
      - name: âœ… Check deployment readiness
        id: check-result
        run: |
          echo "ðŸ” Checking deployment readiness..."
          
          if [ "${{ needs.run-tests.result }}" == "success" ] || [ "${{ github.event.inputs.force_deploy }}" == "true" ] || [ "${{ needs.run-tests.result }}" == "skipped" ]; then
            echo "âœ… Deployment checks passed"
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Tests failed and force_deploy is not enabled"
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  backup-and-migrate:
    runs-on: ubuntu-latest
    name: ðŸ—„ï¸ Database Backup & Migration
    needs: [detect-changes, pre-deployment-checks]
    if: |
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-api == 'true' && 
      github.event.inputs.skip_migrations != 'true'
    
    outputs:
      migration-status: ${{ steps.migration-result.outputs.status }}
      backup-id: ${{ steps.backup.outputs.backup-id }}

    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci

      - name: ðŸ—„ï¸ Create database backup
        id: backup
        if: needs.detect-changes.outputs.environment == 'production'
        run: |
          cd apps/api
          BACKUP_ID="backup-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)"
          echo "ðŸ”„ Creating database backup: $BACKUP_ID"
          
          # Log backup creation (actual implementation would depend on your database provider)
          echo "ðŸ“ Database backup created with ID: $BACKUP_ID"
          echo "backup-id=$BACKUP_ID" >> $GITHUB_OUTPUT
          echo "backup_id=$BACKUP_ID" >> $GITHUB_ENV
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: ðŸš€ Generate Prisma Client
        run: |
          cd apps/api
          npm run db:generate
        env:
          DATABASE_URL: ${{ needs.detect-changes.outputs.environment == 'production' && secrets.DATABASE_URL || secrets.DATABASE_URL_DEV }}

      - name: ðŸ”„ Run database migrations
        run: |
          cd apps/api
          echo "ðŸš€ Running ${{ needs.detect-changes.outputs.environment }} database migrations..."
          npm run db:migrate:deploy
          echo "âœ… Database migrations completed successfully"
        env:
          DATABASE_URL: ${{ needs.detect-changes.outputs.environment == 'production' && secrets.DATABASE_URL || secrets.DATABASE_URL_DEV }}

      - name: âœ… Verify database schema
        run: |
          cd apps/api
          echo "ðŸ” Verifying database schema integrity..."
          node -e "
            const { PrismaClient } = require('@prisma/client');
            const prisma = new PrismaClient();
            
            async function verifySchema() {
              try {
                await prisma.\$connect();
                console.log('âœ… Database connection successful');
                
                // Test basic queries to verify schema
                const userCount = await prisma.user.count().catch(() => 0);
                console.log('ðŸ‘¥ User table accessible, count:', userCount);
                
                // Test other critical tables
                const sessionCount = await prisma.avatarSession.count().catch(() => 0);
                console.log('ðŸ”— AvatarSession table accessible, count:', sessionCount);
                
                await prisma.\$disconnect();
                console.log('âœ… Database schema verification passed');
              } catch (error) {
                console.error('âŒ Database schema verification failed:', error);
                process.exit(1);
              }
            }
            
            verifySchema();
          "
        env:
          DATABASE_URL: ${{ needs.detect-changes.outputs.environment == 'production' && secrets.DATABASE_URL || secrets.DATABASE_URL_DEV }}

      - name: ðŸ“Š Set migration result
        id: migration-result
        run: echo "status=success" >> $GITHUB_OUTPUT

  deploy-api:
    runs-on: ubuntu-latest
    name: ðŸš€ Deploy API to Cloudflare Workers
    needs: [detect-changes, pre-deployment-checks, backup-and-migrate]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-api == 'true' && 
      (needs.backup-and-migrate.result == 'success' || needs.backup-and-migrate.result == 'skipped' || github.event.inputs.skip_migrations == 'true')
    
    outputs:
      api-url: ${{ steps.get-api-url.outputs.url }}
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}

    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci

      - name: ðŸ”§ Install Wrangler CLI
        run: npm install -g wrangler@latest

      - name: ðŸ” Authenticate Wrangler
        run: wrangler whoami
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: ðŸ”¨ Build API
        run: |
          cd apps/api
          echo "ðŸ”¨ Building API for ${{ needs.detect-changes.outputs.environment }}..."
          npm run build
          echo "âœ… API build completed"

      - name: ðŸš€ Deploy API
        id: deploy
        run: |
          cd apps/api
          ENV="${{ needs.detect-changes.outputs.environment }}"
          
          echo "ðŸš€ Deploying API to $ENV environment..."
          
          # Set secrets for the environment
          if [ "$ENV" == "production" ]; then
            echo "${{ secrets.DATABASE_URL }}" | wrangler secret put DATABASE_URL --env production
            echo "${{ secrets.PRIVY_APP_ID }}" | wrangler secret put PRIVY_APP_ID --env production
            echo "${{ secrets.PRIVY_APP_SECRET }}" | wrangler secret put PRIVY_APP_SECRET --env production
            echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET --env production
            echo "${{ secrets.OPENAI_API_KEY }}" | wrangler secret put OPENAI_API_KEY --env production
            
            # Optional: Set OpenAI model configuration for production
            if [ "${{ secrets.OPENAI_MODEL }}" != "" ]; then
              echo "${{ secrets.OPENAI_MODEL }}" | wrangler secret put OPENAI_MODEL --env production
            fi
            if [ "${{ secrets.OPENAI_MAX_TOKENS }}" != "" ]; then
              echo "${{ secrets.OPENAI_MAX_TOKENS }}" | wrangler secret put OPENAI_MAX_TOKENS --env production
            fi
            if [ "${{ secrets.OPENAI_TEMPERATURE }}" != "" ]; then
              echo "${{ secrets.OPENAI_TEMPERATURE }}" | wrangler secret put OPENAI_TEMPERATURE --env production
            fi
            
            echo "ðŸš€ Starting deployment to production..."
            wrangler deploy --env production
            echo "âœ… Deployment command completed"
          else
            echo "${{ secrets.DATABASE_URL_DEV }}" | wrangler secret put DATABASE_URL --env development
            echo "${{ secrets.PRIVY_APP_ID_DEV }}" | wrangler secret put PRIVY_APP_ID --env development
            echo "${{ secrets.PRIVY_APP_SECRET_DEV }}" | wrangler secret put PRIVY_APP_SECRET --env development
            echo "${{ secrets.JWT_SECRET_DEV }}" | wrangler secret put JWT_SECRET --env development
            echo "${{ secrets.OPENAI_API_KEY_DEV }}" | wrangler secret put OPENAI_API_KEY --env development
            
            # Optional: Set OpenAI model configuration for development
            if [ "${{ secrets.OPENAI_MODEL_DEV }}" != "" ]; then
              echo "${{ secrets.OPENAI_MODEL_DEV }}" | wrangler secret put OPENAI_MODEL --env development
            fi
            if [ "${{ secrets.OPENAI_MAX_TOKENS_DEV }}" != "" ]; then
              echo "${{ secrets.OPENAI_MAX_TOKENS_DEV }}" | wrangler secret put OPENAI_MAX_TOKENS --env development
            fi
            if [ "${{ secrets.OPENAI_TEMPERATURE_DEV }}" != "" ]; then
              echo "${{ secrets.OPENAI_TEMPERATURE_DEV }}" | wrangler secret put OPENAI_TEMPERATURE --env development
            fi
            
            echo "ðŸš€ Starting deployment to development..."
            wrangler deploy --env development
            echo "âœ… Deployment command completed"
          fi
          
          DEPLOYMENT_ID="api-$(date +%Y%m%d-%H%M%S)"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          
          echo "âœ… API deployment completed"
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: ðŸ”— Get API URL
        id: get-api-url
        run: |
          if [ "${{ needs.detect-changes.outputs.environment }}" == "production" ]; then
            echo "url=https://sparkmind-api.workers.dev" >> $GITHUB_OUTPUT
          else
            echo "url=https://sparkmind-api-dev.workers.dev" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ¥ API Health Check
        run: |
          echo "ðŸ¥ Performing API health check..."
          sleep 30  # Give deployment time to propagate
          
          API_URL="${{ steps.get-api-url.outputs.url }}"
          MAX_ATTEMPTS=5
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "ðŸ” Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            if curl -f "$API_URL/health" -H "Accept: application/json" --max-time 30; then
              echo "âœ… API health check passed!"
              break
            elif [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "âŒ API health check failed after $MAX_ATTEMPTS attempts"
              exit 1
            else
              echo "â³ Waiting 15 seconds before retry..."
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

  deploy-web:
    runs-on: ubuntu-latest
    name: ðŸŒ Deploy Web App to Cloudflare Pages
    needs: [detect-changes, pre-deployment-checks, deploy-api]
    if: |
      always() && 
      needs.detect-changes.outputs.should-run == 'true' && 
      needs.pre-deployment-checks.outputs.should-deploy == 'true' && 
      needs.detect-changes.outputs.deploy-web == 'true' &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped')
    
    outputs:
      web-url: ${{ steps.deploy-pages.outputs.url }}
      
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci

      - name: ðŸ—ï¸ Create Cloudflare Pages Project (if needed)
        run: |
          PROJECT_NAME="${{ needs.detect-changes.outputs.environment == 'production' && 'sparkmind-web' || 'sparkmind-web-dev' }}"
          echo "ðŸ” Checking if Pages project '$PROJECT_NAME' exists..."
          
          # Check if project exists
          if curl -s -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
               "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME" \
               | grep -q '"success":true'; then
            echo "âœ… Project '$PROJECT_NAME' already exists"
          else
            echo "ðŸ—ï¸ Creating new Pages project '$PROJECT_NAME'..."
            curl -X POST \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" \
              "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects" \
              -d "{\"name\":\"$PROJECT_NAME\",\"production_branch\":\"main\"}"
            echo "âœ… Project '$PROJECT_NAME' created"
          fi

      - name: ðŸ”§ Configure Compatibility Flags
        run: |
          PROJECT_NAME="${{ needs.detect-changes.outputs.environment == 'production' && 'sparkmind-web' || 'sparkmind-web-dev' }}"
          echo "ðŸ”§ Setting nodejs_compat compatibility flag for '$PROJECT_NAME'..."
          
          # Set compatibility flags for production environment
          curl -X PATCH \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/pages/projects/$PROJECT_NAME" \
            -d '{
              "deployment_configs": {
                "production": {
                  "compatibility_flags": ["nodejs_compat"],
                  "compatibility_date": "2024-01-01"
                },
                "preview": {
                  "compatibility_flags": ["nodejs_compat"],
                  "compatibility_date": "2024-01-01"
                }
              }
            }'
          
          echo "âœ… Compatibility flags configured successfully"

      - name: ðŸ”¨ Build web application
        run: |
          cd apps/web
          echo "ðŸ”¨ Building web application for ${{ needs.detect-changes.outputs.environment }}..."
          npm run build:cf
          echo "âœ… Web build completed"
          
          # Verify the output directory was created
          if [ -d ".vercel/output/static" ]; then
            echo "âœ… Output directory '.vercel/output/static' created successfully"
            echo "ðŸ“ Contents:"
            ls -la .vercel/output/static/ | head -10
          else
            echo "âŒ Output directory '.vercel/output/static' not found!"
            echo "ðŸ“ Available directories:"
            find . -type d -name "*output*" -o -name "*vercel*" -o -name "*next*" -o -name "*dist*" | head -10
            ls -la
            exit 1
          fi
        env:
          NODE_ENV: production
          NEXT_PUBLIC_API_URL: ${{ needs.deploy-api.outputs.api-url || (needs.detect-changes.outputs.environment == 'production' && 'https://sparkmind-api.workers.dev' || 'https://sparkmind-api-dev.workers.dev') }}
          NEXT_PUBLIC_PRIVY_APP_ID: ${{ needs.detect-changes.outputs.environment == 'production' && secrets.NEXT_PUBLIC_PRIVY_APP_ID || secrets.NEXT_PUBLIC_PRIVY_APP_ID_DEV }}
          NEXT_PUBLIC_APP_URL: ${{ needs.detect-changes.outputs.environment == 'production' && secrets.NEXT_PUBLIC_APP_URL || secrets.NEXT_PUBLIC_APP_URL_DEV }}
          NEXT_PUBLIC_LIVEKIT_URL: ${{ needs.detect-changes.outputs.environment == 'production' && secrets.NEXT_PUBLIC_LIVEKIT_URL || secrets.NEXT_PUBLIC_LIVEKIT_URL_DEV }}

      - name: ðŸš€ Deploy to Cloudflare Pages
        id: deploy-pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: ${{ needs.detect-changes.outputs.environment == 'production' && 'sparkmind-web' || 'sparkmind-web-dev' }}
          directory: apps/web/.vercel/output/static
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}
          wranglerVersion: '3'

      - name: ðŸ¥ Web App Health Check
        run: |
          echo "ðŸ¥ Performing web app health check..."
          sleep 30  # Give deployment time to propagate
          
          WEB_URL="${{ steps.deploy-pages.outputs.url }}"
          MAX_ATTEMPTS=5
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "ðŸ” Health check attempt $ATTEMPT/$MAX_ATTEMPTS..."
            
            if curl -f "$WEB_URL" --max-time 30 -L; then
              echo "âœ… Web app health check passed!"
              break
            elif [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "âŒ Web app health check failed after $MAX_ATTEMPTS attempts"
              exit 1
            else
              echo "â³ Waiting 15 seconds before retry..."
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

  post-deployment:
    runs-on: ubuntu-latest
    name: ðŸ“‹ Post-deployment Summary
    needs: [detect-changes, backup-and-migrate, deploy-api, deploy-web]
    if: always() && needs.detect-changes.outputs.should-run == 'true'
    
    steps:
      - name: ðŸ“Š Deployment Status Summary
        run: |
          echo "# ðŸš€ Full-Stack Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${{ needs.detect-changes.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Type:** Multi-component (coordinated with API-only workflow)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“‹ Deployment Plan" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Planned | Status | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|--------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ—„ï¸ Database Migration | ${{ needs.detect-changes.outputs.deploy-api == 'true' && 'âœ…' || 'â­ï¸' }} | ${{ needs.backup-and-migrate.result == 'success' && 'âœ… Success' || needs.backup-and-migrate.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸš€ API | ${{ needs.detect-changes.outputs.deploy-api == 'true' && 'âœ…' || 'â­ï¸' }} | ${{ needs.deploy-api.result == 'success' && 'âœ… Success' || needs.deploy-api.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} | ${{ needs.deploy-api.outputs.api-url || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŒ Web App | ${{ needs.detect-changes.outputs.deploy-web == 'true' && 'âœ…' || 'â­ï¸' }} | ${{ needs.deploy-web.result == 'success' && 'âœ… Success' || needs.deploy-web.result == 'skipped' && 'â­ï¸ Skipped' || 'âŒ Failed' }} | ${{ needs.deploy-web.outputs.web-url || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â„¹ï¸ **Note:** API-only changes are handled by the dedicated API deployment workflow for faster iterations." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: ðŸŽ‰ Success Notification
        if: |
          (needs.detect-changes.outputs.deploy-api != 'true' || needs.deploy-api.result == 'success') &&
          (needs.detect-changes.outputs.deploy-web != 'true' || needs.deploy-web.result == 'success')
        run: |
          echo "## ðŸŽ‰ Deployment Completed Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Access Your Application:" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.deploy-web.outputs.web-url }}" != "" ]; then
            echo "- **ðŸŒ Web Application:** [${{ needs.deploy-web.outputs.web-url }}](${{ needs.deploy-web.outputs.web-url }})" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ needs.deploy-api.outputs.api-url }}" != "" ]; then
            echo "- **ðŸš€ API Endpoint:** [${{ needs.deploy-api.outputs.api-url }}](${{ needs.deploy-api.outputs.api-url }})" >> $GITHUB_STEP_SUMMARY
            echo "- **ðŸ¥ API Health:** [${{ needs.deploy-api.outputs.api-url }}/health](${{ needs.deploy-api.outputs.api-url }}/health)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸ’¬ Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const apiDeployed = '${{ needs.deploy-api.result }}' === 'success';
            const webDeployed = '${{ needs.deploy-web.result }}' === 'success';
            const apiUrl = '${{ needs.deploy-api.outputs.api-url }}';
            const webUrl = '${{ needs.deploy-web.outputs.web-url }}';
            const environment = '${{ needs.detect-changes.outputs.environment }}';
            
            let comment = `ðŸš€ **Deployment Preview Ready!**\n\n`;
            comment += `**Environment:** \`${environment}\`\n\n`;
            
            if (apiDeployed && webDeployed) {
              comment += `âœ… **Full Stack Deployed**\n`;
              comment += `- ðŸŒ **Web App:** [${webUrl}](${webUrl})\n`;
              comment += `- ðŸš€ **API:** [${apiUrl}](${apiUrl})\n`;
              comment += `- ðŸ¥ **Health Check:** [${apiUrl}/health](${apiUrl}/health)\n`;
            } else if (apiDeployed) {
              comment += `âœ… **API Deployed**\n`;
              comment += `- ðŸš€ **API:** [${apiUrl}](${apiUrl})\n`;
              comment += `- ðŸ¥ **Health Check:** [${apiUrl}/health](${apiUrl}/health)\n`;
            } else if (webDeployed) {
              comment += `âœ… **Web App Deployed**\n`;
              comment += `- ðŸŒ **Web App:** [${webUrl}](${webUrl})\n`;
            } else {
              comment += `â„¹ï¸ **No components were deployed** (no relevant changes detected)\n`;
            }
            
            comment += `\n### ðŸ§ª Testing Checklist:\n`;
            if (webDeployed) {
              comment += `- [ ] Web app loads correctly\n`;
              comment += `- [ ] Navigation works as expected\n`;
              comment += `- [ ] No console errors\n`;
            }
            if (apiDeployed) {
              comment += `- [ ] API health check passes\n`;
              comment += `- [ ] Database connectivity works\n`;
            }
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: ðŸš¨ Failure Notification
        if: failure()
        run: |
          echo "# ðŸš¨ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ”„ Quick Recovery Options:" >> $GITHUB_STEP_SUMMARY
          echo "1. **ðŸ”„ Revert & Redeploy:**" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "   git revert ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "   git push origin main" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. **ðŸŽ¯ Manual Deployment:** Use \`workflow_dispatch\` to deploy specific components" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "3. **ðŸ” Debug:** Check failed job logs above for specific errors" >> $GITHUB_STEP_SUMMARY 